package org.occleve.mobileclient;

import java.io.*;

/**Contains a 94x94 array mapping GB2312 characters to Unicode characters.
This array is needed in order to build the correct URL for retrieving the Ocrat
stroke-order animations, whose filenames are encoded in GB2312.
Generated by the BuildGB2312ToUnicodeArray class.
Previously, attempted to hardcode into this class as a static-initialized arry,
but had to switch to loading from a resource file because that caused
the "Maximum byte code length (32kB) exceeded" error.*/
public class GB2312ToUnicodeMap
{
	private char[][] m_Array;

	private final int MAX_ROW =87;
	private final int MAX_COL = 94;
	
	public GB2312ToUnicodeMap() throws Exception
	{
		if (m_Array==null)
		{
	        // Reading the file from the OccleveMobileClient jar,
	        // therefore call getResourceAsStream() on the midlet class
	        // in order to ensure that the correct JAR is read from.
	        Class c = OccleveMobileMidlet.getInstance().getClass();
	        InputStream is =
	        	c.getResourceAsStream("/" + Config.GB2312_TO_UNICODE_ARRAY_FILE);
	        if (is == null)
	        {
	            throw new Exception("Can't find GB2312->Unicode file in JAR");
	        }

	        m_Array = new char[MAX_ROW+1][MAX_COL+1];
	        DataInputStream dis = new DataInputStream(is);

			for (int iGB2312Row = 1; iGB2312Row<=MAX_ROW; iGB2312Row++)
			{
				for (int iGB2312Col = 1; iGB2312Col<=MAX_COL; iGB2312Col++)
				{
					long lUnicodeChar = dis.readLong();
					char cUnicodeChar = (char)lUnicodeChar;
					m_Array[iGB2312Row][iGB2312Col] = cUnicodeChar;
				}
			}

			dis.close();
			is.close();
		}
	}
	
	public byte[] unicodeCharToEucCnBytePair(char cUnicodeChar)
	{
		// According to Wikipedia, "The rows 10-15 and 88-94 are unassigned"
		
		for (int iGB2312Row = 1; iGB2312Row<=MAX_ROW; iGB2312Row++)
		{
			for (int iGB2312Col = 1; iGB2312Col<=MAX_COL; iGB2312Col++)
			{
				if (iGB2312Row<10 || iGB2312Row>15)
				{
					if (cUnicodeChar == m_Array[iGB2312Row][iGB2312Col])
					{
						// This uses the prescription giving for encoding GB2312 using
						// EUC-CN given at http://en.wikipedia.org/wiki/GB2312#EUC-CN
						int iHighByte = iGB2312Row + 160;
						int iLowByte = iGB2312Col + 160;
						byte[] returnMe = {(byte)iHighByte,(byte)iLowByte};
						return returnMe;
					}
				}
			}
		}

		byte[] returnMe = {0,0};
		return returnMe;
	}
}
